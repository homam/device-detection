// Generated by LiveScript 1.2.0
(function(){
  var prelude, ref$, Obj, map, filter, each, find, fold, foldr, fold1, all, flatten, sum, groupBy, objToPairs, partition, join, unique, sortBy, maximum, minimum, pow, sqrt, floor, round, exports;
  prelude = require('prelude-ls');
  ref$ = require('prelude-ls'), Obj = ref$.Obj, map = ref$.map, filter = ref$.filter, each = ref$.each, find = ref$.find, fold = ref$.fold, foldr = ref$.foldr, fold1 = ref$.fold1, all = ref$.all, flatten = ref$.flatten, sum = ref$.sum, groupBy = ref$.groupBy, objToPairs = ref$.objToPairs, partition = ref$.partition, join = ref$.join, unique = ref$.unique, sortBy = ref$.sortBy, maximum = ref$.maximum, minimum = ref$.minimum;
  pow = Math.pow;
  sqrt = Math.sqrt;
  floor = Math.floor;
  round = Math.round;
  exports = exports || this;
  exports.devicesHistogram = function(width, height){
    var bins, margins, x, y, $svg, color, updateTree;
    width == null && (width = 1000);
    height == null && (height = 1000);
    height = 600;
    width = 1000;
    bins = 20;
    margins = [20, 50, 50, 20];
    x = d3.scale.ordinal().rangeRoundBands([0, width - margins[1] - margins[3]]).domain((function(){
      var i$, to$, results$ = [];
      for (i$ = 0, to$ = bins - 1; i$ <= to$; ++i$) {
        results$.push(i$);
      }
      return results$;
    }()));
    y = d3.scale.linear().range([0, height - margins[0] - margins[2]]);
    $svg = d3.select(".tree").append("svg").attr("class", "devices-histogram").attr("width", width).attr("height", height).append("g").attr("transform", "translate(" + margins[3] + "," + (height - margins[2]) + ")");
    color = d3.scale.category10();
    updateTree = function(root, selectedStats){
      var transition, untree, convMax, convMin, binSize, makeY0, blocks, $bin, $binEnter, $device, $deviceEnter, $renderNodeMethodsStats;
      transition = function(node){
        return node.transition().duration(500);
      };
      untree = function(){
        return map(function(it){
          it.selectedStats = selectedStats(it);
          return it;
        })(filter(function(it){
          return !!it && !!it.stats;
        })(foldRealNodes(root, function(n, acc){
          return [n].concat(acc);
        }, null)));
      }();
      convMax = maximum(map(function(it){
        return it.selectedStats[2];
      })(untree));
      convMin = 0;
      binSize = convMax / (bins - 1);
      makeY0 = function(){
        var last;
        last = 0;
        return function(d){
          var current;
          current = last;
          last = d.y + last;
          return current;
        };
      };
      blocks = function(){
        return function(input){
          var i$, len$, ref$, t, y0, results$ = [];
          for (i$ = 0, len$ = input.length; i$ < len$; ++i$) {
            ref$ = input[i$], t = ref$[0], y0 = ref$[1];
            results$.push({
              name: t.name,
              values: map(fn$, t.values)
            });
          }
          return results$;
          function fn$(it){
            it.y0 = y0(it);
            return it;
          }
        }(map(function(it){
          return [it, makeY0()];
        })(function(input){
          var i$, len$, ref$, name, values, results$ = [];
          for (i$ = 0, len$ = input.length; i$ < len$; ++i$) {
            ref$ = input[i$], name = ref$[0], values = ref$[1];
            results$.push({
              name: parseInt(name),
              values: sortBy(fn$, values)
            });
          }
          return results$;
          function fn$(it){
            return -it.y;
          }
        }(objToPairs(groupBy(function(it){
          return it.x;
        })(map(function(it){
          it.x = round(it.selectedStats[2] / binSize);
          it.y = it.selectedStats[0];
          return it;
        })(untree))))));
      }();
      blocks = function(){
        return map(function(b){
          return {
            name: b,
            values: (find(function(it){
              return it.name === b;
            }, blocks) || {
              values: []
            }).values
          };
        })((function(){
          var i$, to$, results$ = [];
          for (i$ = 0, to$ = bins - 1; i$ <= to$; ++i$) {
            results$.push(i$);
          }
          return results$;
        }()));
      }();
      y.domain([
        0, function(){
          return maximum(map(function(it){
            return it.y + it.y0;
          })(flatten(map(function(it){
            return it.values;
          })(blocks))));
        }()
      ]);
      $bin = $svg.selectAll('g.bin').data(blocks);
      $binEnter = $bin.enter().append('g').attr('class', 'bin');
      $bin.exit().remove();
      $bin.attr("transform", function(it){
        return "translate(" + x(it.name) + "," + margins[0] + ")";
      });
      $binEnter.append('text').attr('class', 'bin-label').attr("text-anchor", "middle").attr("dy", "1em");
      $bin.select('text.bin-label').attr("x", x.rangeBand() / 2).attr("y", 0).text(function(it){
        return d3.format('.1%')(it.name * binSize);
      });
      $device = $bin.selectAll('g.device').data(function(it){
        return it.values;
      });
      $deviceEnter = $device.enter().append('g').attr('class', 'device').on('mousedown', function(it){
        return $renderNodeMethodsStats(it);
      });
      $deviceEnter.append('rect');
      $device.select('rect').attr('class', function(it){
        return "node-" + it.treeId;
      }).attr("width", function(){
        return x.rangeBand();
      }).attr("height", function(it){
        return y(it.y);
      }).attr("x", 0).attr("y", function(it){
        return -y(it.y0) - y(it.y);
      }).style("fill", function(it){
        return color(it.os);
      });
      $device.exit().remove();
      return $renderNodeMethodsStats = function(node){
        return $(window).trigger("tree/node-selected", [node]);
      };
    };
    $(window).on("tree/node-selected", function(ref$, node){
      d3.selectAll('rect.selected').classed('selected', false);
      return eachTreeNode(function(it){
        return d3.select(".node-" + it.treeId).classed('selected', true);
      }, node);
    });
    return {
      $svg: $svg,
      updateTree: updateTree
    };
  };
}).call(this);
