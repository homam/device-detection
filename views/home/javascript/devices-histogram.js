// Generated by LiveScript 1.2.0
(function(){
  var prelude, ref$, Obj, map, filter, each, find, fold, foldr, fold1, all, flatten, sum, groupBy, objToPairs, partition, join, unique, sortBy, maximum, minimum, pow, sqrt, floor, round, formatDate, hardClone, trace, sor, nameNode, shortenWurflDeviceName, _sumStats, sumVisits, sumSubscribers, updateAllNodes, killChildrenByCriteria, killChildren, stats, exports;
  prelude = require('prelude-ls');
  ref$ = require('prelude-ls'), Obj = ref$.Obj, map = ref$.map, filter = ref$.filter, each = ref$.each, find = ref$.find, fold = ref$.fold, foldr = ref$.foldr, fold1 = ref$.fold1, all = ref$.all, flatten = ref$.flatten, sum = ref$.sum, groupBy = ref$.groupBy, objToPairs = ref$.objToPairs, partition = ref$.partition, join = ref$.join, unique = ref$.unique, sortBy = ref$.sortBy, maximum = ref$.maximum, minimum = ref$.minimum;
  pow = Math.pow;
  sqrt = Math.sqrt;
  floor = Math.floor;
  round = Math.round;
  formatDate = d3.time.format('%Y-%m-%d');
  hardClone = function(it){
    return JSON.parse(JSON.stringify(it));
  };
  trace = function(v){
    console.log(v);
    return v;
  };
  sor = function(a, b){
    if (!!a && a.length > 0 && a !== ' ') {
      return a;
    } else {
      return b;
    }
  };
  nameNode = function(n){
    return sor(sor(sor(n.device, n.brand), n.os), '');
  };
  shortenWurflDeviceName = function(name){
    var verIndex;
    if (!name) {
      return name;
    }
    verIndex = name.indexOf("ver");
    return verIndex > 0 ? name.substr(0, verIndex + 1) + '..' : name;
  };
  _sumStats = curry$(function(methodSelector, prop, node){
    var m;
    return fold1(curry$(function(x$, y$){
      return x$ + y$;
    }))((function(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = node.stats).length; i$ < len$; ++i$) {
        m = ref$[i$];
        if (methodSelector(m.method)) {
          results$.push(m[prop]);
        }
      }
      return results$;
    }()));
  });
  sumVisits = curry$(function(methodSelector, node){
    return _sumStats(methodSelector, 'visits', node);
  });
  sumSubscribers = curry$(function(methodSelector, node){
    return _sumStats(methodSelector, 'subscribers', node);
  });
  updateAllNodes = curry$(function(updater, node){
    switch (false) {
    case node.children.length !== 0:
      node;
      break;
    default:
      map(updateAllNodes(updater), node.children);
    }
    return updater(node);
  });
  killChildrenByCriteria = curry$(function(criteria, node){
    switch (false) {
    case node.children.length !== 0:
      node;
      break;
    default:
      node.children = filter(function(it){
        return criteria(it);
      }, node.children);
      map(killChildrenByCriteria(criteria), node.children);
    }
    return node;
  });
  killChildren = curry$(function(minVisits, visitsSelector, node){
    return killChildrenByCriteria(function(it){
      return visitsSelector(it) > minVisits;
    }, node);
  });
  stats = function(methodFilter, node){
    var v, s, c;
    v = sumVisits(methodFilter, node);
    s = sumSubscribers(methodFilter, node);
    c = v === 0
      ? 0
      : s / v;
    return [v, s, c];
  };
  exports = exports || this;
  exports.devicesHistogram = function(width, height){
    var bins, margins, x, y, $svg, color, updateTree;
    width == null && (width = 1000);
    height == null && (height = 1000);
    height = 600;
    width = 1000;
    bins = 20;
    margins = [20, 50, 50, 20];
    x = d3.scale.ordinal().rangeRoundBands([0, width - margins[1] - margins[3]]).domain((function(){
      var i$, to$, results$ = [];
      for (i$ = 0, to$ = bins - 1; i$ <= to$; ++i$) {
        results$.push(i$);
      }
      return results$;
    }()));
    y = d3.scale.linear().range([0, height - margins[0] - margins[2]]);
    $svg = d3.select(".tree").append("svg").attr("class", "devices-histogram").attr("width", width).attr("height", height).append("g").attr("transform", "translate(" + margins[3] + "," + (height - margins[2]) + ")");
    color = d3.scale.category10();
    updateTree = function(root, selectedSubscriptionMethods, selectedSubscriptionMethodsOr, excludeDesktop, killChildrenThreshold){
      var createMethodFilter, selectedMethodFilter, selectedVisits, selectedSubscribers, selectedStats, ref$, totalVisitsSelected, totalSubscribersSelected, convAverageSelected, convStnDevSelected, transition, untree, convMax, convMin, binSize, makeY0, blocks, $bin, $binEnter, $device, $deviceEnter, $renderNodeMethodsStats;
      killChildrenThreshold == null && (killChildrenThreshold = 100);
      if (excludeDesktop) {
        root.children = filter(function(it){
          return it.os !== 'Desktop';
        }, root.children);
      }
      createMethodFilter = function(selectedMethods){
        return function(method){
          return in$(method, selectedMethods);
        };
      };
      selectedMethodFilter = !selectedSubscriptionMethods
        ? function(){
          return true;
        }
        : createMethodFilter(selectedSubscriptionMethods);
      selectedVisits = sumVisits(selectedMethodFilter);
      selectedSubscribers = sumSubscribers(selectedMethodFilter);
      selectedStats = function(node){
        return stats(selectedMethodFilter, node);
      };
      ref$ = selectedStats(root), totalVisitsSelected = ref$[0], totalSubscribersSelected = ref$[1], convAverageSelected = ref$[2];
      convStnDevSelected = foldRealNodes(root, function(n, acc){
        var ref$, v, s, conv;
        ref$ = selectedStats(n), v = ref$[0], s = ref$[1], conv = ref$[2];
        return acc + sqrt(pow(conv - convAverageSelected, 2)) * v / totalVisitsSelected;
      }, 0);
      transition = function(node){
        return node.transition().duration(500);
      };
      if (selectedSubscriptionMethodsOr) {
        root = killChildren(killChildrenThreshold, selectedVisits, root);
      } else {
        root = killChildrenByCriteria(function(node){
          var m;
          return all(function(it){
            return it;
          }, (function(){
            var i$, ref$, len$, results$ = [];
            for (i$ = 0, len$ = (ref$ = selectedSubscriptionMethods).length; i$ < len$; ++i$) {
              m = ref$[i$];
              results$.push(find(fn$, node.stats).visits > killChildrenThreshold);
            }
            return results$;
            function fn$(it){
              return it.method === m;
            }
          }()));
        }, root);
      }
      untree = function(){
        return map(function(it){
          it.selectedStats = selectedStats(it);
          return it;
        })(filter(function(it){
          return !!it && !!it.stats;
        })(foldRealNodes(root, function(n, acc){
          return [n].concat(acc);
        }, null)));
      }();
      convMax = maximum(map(function(it){
        return it.selectedStats[2];
      })(untree));
      convMin = 0;
      binSize = convMax / (bins - 1);
      makeY0 = function(){
        var last;
        last = 0;
        return function(d){
          var current;
          current = last;
          last = d.y + last;
          return current;
        };
      };
      blocks = function(){
        return function(input){
          var i$, len$, ref$, t, y0, results$ = [];
          for (i$ = 0, len$ = input.length; i$ < len$; ++i$) {
            ref$ = input[i$], t = ref$[0], y0 = ref$[1];
            results$.push({
              name: t.name,
              values: map(fn$, t.values)
            });
          }
          return results$;
          function fn$(it){
            it.y0 = y0(it);
            return it;
          }
        }(map(function(it){
          return [it, makeY0()];
        })(function(input){
          var i$, len$, ref$, name, values, results$ = [];
          for (i$ = 0, len$ = input.length; i$ < len$; ++i$) {
            ref$ = input[i$], name = ref$[0], values = ref$[1];
            results$.push({
              name: parseInt(name),
              values: sortBy(fn$, values)
            });
          }
          return results$;
          function fn$(it){
            return -it.y;
          }
        }(objToPairs(groupBy(function(it){
          return it.x;
        })(map(function(it){
          it.x = round(it.selectedStats[2] / binSize);
          it.y = it.selectedStats[0];
          return it;
        })(untree))))));
      }();
      blocks = function(){
        return map(function(b){
          return {
            name: b,
            values: (find(function(it){
              return it.name === b;
            }, blocks) || {
              values: []
            }).values
          };
        })((function(){
          var i$, to$, results$ = [];
          for (i$ = 0, to$ = bins - 1; i$ <= to$; ++i$) {
            results$.push(i$);
          }
          return results$;
        }()));
      }();
      y.domain([
        0, function(){
          return maximum(map(function(it){
            return it.y + it.y0;
          })(flatten(map(function(it){
            return it.values;
          })(blocks))));
        }()
      ]);
      $bin = $svg.selectAll('g.bin').data(blocks);
      $binEnter = $bin.enter().append('g').attr('class', 'bin');
      $bin.exit().remove();
      $bin.attr("transform", function(it){
        return "translate(" + x(it.name) + "," + margins[0] + ")";
      });
      $binEnter.append('text').attr('class', 'bin-label').attr("text-anchor", "middle").attr("dy", "1em");
      $bin.select('text.bin-label').attr("x", x.rangeBand() / 2).attr("y", 0).text(function(it){
        return d3.format('.1%')(it.name * binSize);
      });
      $device = $bin.selectAll('g.device').data(function(it){
        return it.values;
      });
      $deviceEnter = $device.enter().append('g').attr('class', 'device').on('mousedown', function(it){
        return $renderNodeMethodsStats(it);
      });
      $deviceEnter.append('rect');
      $device.select('rect').attr('class', function(it){
        return "node-" + it.treeId;
      }).attr("width", function(){
        return x.rangeBand();
      }).attr("height", function(it){
        return y(it.y);
      }).attr("x", 0).attr("y", function(it){
        return -y(it.y0) - y(it.y);
      }).style("fill", function(it){
        return color(it.os);
      });
      $device.exit().remove();
      return $renderNodeMethodsStats = function(node){
        return $(window).trigger("tree/node-selected", [node]);
      };
    };
    $(window).on("tree/node-selected", function(ref$, node){
      d3.selectAll('rect.selected').classed('selected', false);
      return eachTreeNode(function(it){
        return d3.select(".node-" + it.treeId).classed('selected', true);
      }, node);
    });
    return {
      $svg: $svg,
      updateTree: updateTree
    };
  };
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);
