// Generated by LiveScript 1.2.0
(function(){
  var ref$, Obj, map, filter, find, fold, foldr, fold1, all, flatten, sum, groupBy, objToPairs, partition, join, unique, request, hardClone, hardCloneWithoutChildren, reduceTree, treefy;
  ref$ = require('prelude-ls'), Obj = ref$.Obj, map = ref$.map, filter = ref$.filter, find = ref$.find, fold = ref$.fold, foldr = ref$.foldr, fold1 = ref$.fold1, all = ref$.all, flatten = ref$.flatten, sum = ref$.sum, groupBy = ref$.groupBy, objToPairs = ref$.objToPairs, partition = ref$.partition, join = ref$.join, unique = ref$.unique;
  request = require('request');
  hardClone = function(it){
    return JSON.parse(JSON.stringify(it));
  };
  hardCloneWithoutChildren = function(it){
    var cs, me;
    cs = it.children;
    delete it.children;
    me = hardClone(it);
    me.children = [];
    it.children = cs;
    return [it, me];
  };
  reduceTree = function(method, property, node){
    var c;
    switch (false) {
    case node.children.length !== 0:
      return find(function(it){
        return it.method === method;
      }, node.stats)[property];
    default:
      return fold1(curry$(function(x$, y$){
        return x$ + y$;
      }), flatten((function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = node.children).length; i$ < len$; ++i$) {
          c = ref$[i$];
          results$.push(reduceTree(method, property, c));
        }
        return results$;
      }())));
    }
  };
  treefy = function(){
    return function(raw){
      var data, root, emptyStats, methods, methodStatsOrEmpty, collectStats;
      data = map(function(r){
        r.children = [];
        return r;
      }, hardClone(raw));
      root = {
        children: [],
        device: 'root'
      };
      emptyStats = function(method){
        return {
          method: method,
          visits: 0,
          subscribers: 0
        };
      };
      methods = unique(flatten(map(function(it){
        var i$, ref$, len$, m, results$ = [];
        for (i$ = 0, len$ = (ref$ = it.stats).length; i$ < len$; ++i$) {
          m = ref$[i$];
          results$.push(m.method);
        }
        return results$;
      }, data)));
      methodStatsOrEmpty = function(method, stats){
        return find(function(it){
          return it.method === method;
        }, stats) || emptyStats(method);
      };
      data = map(function(it){
        var res$, i$, ref$, len$, m;
        res$ = [];
        for (i$ = 0, len$ = (ref$ = methods).length; i$ < len$; ++i$) {
          m = ref$[i$];
          res$.push(methodStatsOrEmpty(m, it.stats));
        }
        it.stats = res$;
        return it;
      }, data);
      map(function(it){
        var ref$, parent, me, res$, i$, len$, m;
        ref$ = hardCloneWithoutChildren(it), parent = ref$[0], me = ref$[1];
        parent.children.push(me);
        res$ = [];
        for (i$ = 0, len$ = (ref$ = methods).length; i$ < len$; ++i$) {
          m = ref$[i$];
          res$.push(emptyStats(m));
        }
        parent.stats = res$;
        return parent;
      })(filter(function(it){
        return it.children.length > 0;
      })(map(function(it){
        (find(function(d){
          return d.device === it.fall_back;
        }, data) || root).children.push(it);
        return it;
      })(data)));
      collectStats = function(node){
        var r, res$, i$, ref$, len$, m;
        switch (false) {
        case node.children.length !== 0:
          return node.stats;
        default:
          res$ = [];
          for (i$ = 0, len$ = (ref$ = methods).length; i$ < len$; ++i$) {
            m = ref$[i$];
            res$.push({
              method: m,
              visits: reduceTree(m, 'visits', node),
              subscribers: reduceTree(m, 'subscribers', node)
            });
          }
          r = res$;
          map(function(it){
            return it.stats = collectStats(it);
          }, node.children);
          return r;
        }
      };
      root.stats = collectStats(root);
      return root;
    };
  }();
  exports.treefy = treefy;
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
